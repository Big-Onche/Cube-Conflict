///////////////////////////////////////////////////
//
// material shaders
//
///////////////////////////////////////////////////

shader 0 "refractmask" [
    attribute vec4 vvertex;
    uniform mat4 camprojmatrix;
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
    }
] [
    @(gfetchdefs tex0)
    uniform vec3 gdepthpackparams;
    fragdata(0) vec4 fragcolor;
    void main(void)
    {
        @(if (= $gdepthformat 1) [result [
            vec3 packdepth = gfetch(tex0, gl_FragCoord.xy).rgb;
        ]] [result [
            @(gdepthunpack depth [gfetch(tex0, gl_FragCoord.xy)])
            @(gpackdepth packdepth depth)
        ]])
        fragcolor = vec4(packdepth, 0.0);
    }
]

lazyshader 0 "waterminimap" [
    attribute vec4 vvertex;
    uniform mat4 camprojmatrix;
    @(ginterpvert)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        @(gdepthpackvert)
    }
] [
    uniform vec3 watercolor;
    @(ginterpfrag)

    void main(void)
    {
        gcolor = vec4(watercolor, 0.0);
        @(gnormpack [vec3(0.5, 0.5, 1.0)])
        @(gdepthpackfrag)
    }
]

watershader = [
  lazyshader 0 $arg1 [
    attribute vec4 vvertex;
    uniform mat4 camprojmatrix;
    uniform vec3 camera;
    uniform vec2 watertexgen;
    uniform float millis;
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    varying vec3 surface;
    @(? (>= (strstr $arg1 "reflect") 0) [
        uniform mat4 raymatrix;
        varying vec3 esurface;
    ])
    @(ginterpvert 1)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        surface = vvertex.xyz;
        @(? (>= (strstr $arg1 "reflect") 0) [
            esurface = (raymatrix * vvertex).xyz;
        ])
        
        vec2 tc = vvertex.xy * watertexgen;
        texcoord0 = tc * 0.18 + millis*vec2( 0.25,  0.75)*0.1250;
        texcoord1 = tc * 0.18 + millis*vec2(-0.75, -0.25)*0.1450;
        texcoord2 = tc * 0.08 + millis*vec2(-0.50,  0.50)*0.0805;
        texcoord3 = tc * 0.08 + millis*vec2( 0.25, -0.75)*0.0825;

        @(gdepthpackvert 1)
    }
  ] [
    @(gfetchdefs [tex7 tex8 tex9])
    uniform vec3 camera;
    uniform mat4 linearworldmatrix;
    varying vec2 texcoord0, texcoord1, texcoord2, texcoord3;
    varying vec3 surface;
    uniform sampler2D tex0, tex1;
    uniform vec4 viewsize;
    uniform vec3 watercolor, waterdeepcolor, waterdeepfade;
    uniform float waterfog, waterspec;
    uniform vec4 waterreflect, waterrefract;
    uniform float refractdepth;
    @(? (>= (strstr $arg1 "caustics") 0) [
        uniform vec3 causticsS, causticsT;
        uniform vec3 causticsblend;
        uniform sampler2D tex2, tex3;
    ])
    @(? (>= (strstr $arg1 "env") 0) [
        uniform samplerCube tex4;
    ])
    @(? (>= (strstr $arg1 "reflect") 0) [
        uniform mat4 raymatrix;
        varying vec3 esurface;
    ])
    @(ginterpfrag 1)

    void main(void)
    {
        vec3 camdir = camera - surface, camvec = normalize(camdir);
        vec3 bump  = texture2D(tex1, texcoord0).rgb;
        vec3 bump2 = texture2D(tex1, texcoord1).rgb;
        vec3 bump3 = texture2D(tex1, texcoord2).rgb;
        vec3 bump4 = texture2D(tex1, texcoord3).rgb;
        bump = normalize(bump + bump2 + bump3 + bump4 - 2.0);
        vec2 rtc = bump.xy * waterrefract.w;

        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb * waterrefract.xyz;
        float rdepth = dot(gfetch(tex7, rtc).rgb, gdepthunpackparams);
        vec3 rpos = (linearworldmatrix * vec4(rdepth*rtc, rdepth, 1.0)).xyz;

        @(if (>= (strstr $arg1 "under") 0) [result [
            float above = rpos.z - surface.z;
            float alpha = clamp(above, 0.0, 1.0);
        ]] [result [
            vec3 rdir = rpos.xyz - camera;
            float raydepth = length(rdir)*(1.0 + camdir.z/rdir.z);
            float deep = surface.z - rpos.z;
            float alpha = clamp(deep*0.5, 0.0, 1.0);

            @(? (>= (strstr $arg1 "caustics") 0) [
                vec2 ctc = vec2(dot(causticsS, rpos.xyz), dot(causticsT, rpos.xyz));
                float caustics = causticsblend.x*texture2D(tex2, ctc).r + causticsblend.y*texture2D(tex3, ctc).r + causticsblend.z;
                rcolor *= caustics;
            ])

            rcolor = mix(watercolor, rcolor, clamp(exp2(waterfog * raydepth), 0.0, 1.0));
            rcolor = mix(waterdeepcolor, rcolor, clamp(exp2(deep * waterdeepfade), 0.0, 1.0));
        ]])

        vec3 reflectdir = -reflect(camvec, bump);
        reflectdir.z = abs(reflectdir.z);
        @(if (>= (strstr $arg1 "reflect") 0) [result [
            reflectdir.z += 0.125;
            vec3 edir = (raymatrix * vec4(waterreflect.w*reflectdir, 0.0)).xyz;
            vec3 epos = esurface + edir;
            @(loopconcat i 4 [result [
                @(gdepthunpack [edepth@[i]] [gfetchproj(tex9, epos)] [
                    if(edepth@[i] < epos.z || edepth@[i] > esurface.z) epos += edir;
                ] [
                    edepth@[i] = edepth@[i]*gdepthscale.y + gdepthscale.z;
                    if(gdepthscale.x < epos.z*edepth@[i] || gdepthscale.x > esurface.z*edepth@[i]) epos += edir;
                ])
            ]])
            vec2 etc = epos.xy/epos.z;
            @(? $msaalight [
                etc = clamp(etc, vec2(0.0), viewsize.xy);
            ])
            vec3 reflect = gfetch(tex8, etc).rgb * waterreflect.xyz;
            float edgefade = clamp(4.0*(0.5 - max(abs(etc.x*viewsize.z - 0.5)*0.75 + 0.25/4.0, abs(etc.y*viewsize.w - 0.5))), 0.0, 1.0);
            float fresnel = 0.25 + 0.75*pow(clamp(1.0 - dot(camvec, bump), 0.0, 1.0), 4.0);
            rcolor = mix(rcolor, reflect, fresnel*edgefade);
        ]] [if (>= (strstr $arg1 "env") 0) [result [
            vec3 reflect = textureCube(tex4, reflectdir).rgb*0.5;
            float fresnel = 0.5*pow(clamp(1.0 - dot(camvec, bump), 0.0, 1.0), 4.0);
            rcolor = mix(rcolor, reflect, fresnel);
        ]]])

        gcolor.rgb = vec3(0.0);
        @(gspecpack 2.0 [waterspec*alpha])
        @(gnormpack bump alpha)
        gglow.rgb = rcolor*alpha;
        @(gdepthpackfrag)
    }
  ]
]

watershader "water"
watershader "watercaustics"
watershader "waterenv"
watershader "waterenvcaustics"
watershader "waterreflect"
watershader "waterreflectcaustics"
watershader "underwater"

causticshader = [
    lazyshader 0 $arg1 [
        attribute vec4 vvertex;
        void main(void)
        {
            gl_Position = vvertex;
        }
    ] [
        @(gfetchdefs tex9)
        uniform mat4 causticsmatrix;
        uniform vec3 causticsblend;
        uniform sampler2D tex0, tex1;
        uniform vec4 waterdeepfade;
        fragdata(0) vec4 fragcolor;
        void main(void)
        {
            @(gdepthunpack depth [gfetch(tex9, gl_FragCoord.xy)] [
                vec3 ctc = (causticsmatrix * vec4(depth*gl_FragCoord.xy, depth, 1.0)).xyz;
            ] [
                vec4 ctc = causticsmatrix * vec4(gl_FragCoord.xy, depth, 1.0);
                ctc.xyz /= ctc.w;
            ])
            float caustics = causticsblend.x*texture2D(tex0, ctc.xy).r + causticsblend.y*texture2D(tex1, ctc.xy).r + causticsblend.z;
            caustics *= clamp(ctc.z, 0.0, 1.0) * clamp(exp2(ctc.z*waterdeepfade.w), 0.0, 1.0);
            fragcolor.rgb = vec3(0.5 + caustics);
        }
    ]
]
causticshader caustics

waterfogshader = [
    lazyshader 0 $arg1 [
        attribute vec4 vvertex;
        void main(void)
        {
            gl_Position = vvertex;
        }
    ] [
        @(gfetchdefs tex9)
        uniform vec3 camera;
        uniform mat4 worldmatrix;
        uniform vec3 fogcolor;
        uniform vec2 fogdensity;
        uniform vec3 waterdeepcolor, waterdeepfade;
        uniform float waterheight;
        fragdata(0) vec4 fragcolor;
        void main(void)
        {
            @(gdepthunpack depth [gfetch(tex9, gl_FragCoord.xy)] [
                vec3 pos = (worldmatrix * vec4(depth*gl_FragCoord.xy, depth, 1.0)).xyz;
            ] [
                vec4 pos = worldmatrix * vec4(gl_FragCoord.xy, depth, 1.0);
                pos.xyz /= pos.w;
            ])
            float fogbelow = waterheight - pos.z;
            float fogcoord = distance(camera, pos.xyz);
            float foglerp = clamp(1.0 - exp2(fogcoord*fogdensity.x)*fogdensity.y, 0.0, 1.0);
            foglerp *= clamp(2.0*fogbelow + 0.5, 0.0, 1.0);
            vec3 color = mix(waterdeepcolor, fogcolor, clamp(exp2(fogbelow*waterdeepfade), 0.0, 1.0));
            fragcolor.rgb = color;
            fragcolor.a = foglerp;
        }
    ]
]
waterfogshader waterfog

lazyshader 0 "lava" [
    attribute vec4 vvertex;
    attribute vec3 vnormal;
    uniform mat4 camprojmatrix;
    varying mat3 world;
    uniform vec4 lavatexgen;
    varying vec2 texcoord0;
    @(ginterpvert)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(vnormal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(vnormal.z));
        world = mat3(tangent, bitangent, vnormal);
        vec2 tc = vec2(dot(vvertex.xy, tangent.xy), dot(vvertex.yz, bitangent.yz));
        texcoord0 = (tc + lavatexgen.zw) * lavatexgen.xy;
        @(gdepthpackvert)
    }
] [
    uniform sampler2D tex0, tex1;
    uniform float lavaglow, lavaspec;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpfrag)

    void main(void)
    {
        vec3 diffuse = texture2D(tex0, texcoord0).rgb;
        vec3 bump = texture2D(tex1, texcoord0).rgb*2.0-1.0;
        vec3 bumpw = normalize(world * bump);
        gcolor.rgb = diffuse;
        @(gspecpack 0.0 lavaspec)
        @(gnormpack bumpw)
        gglow.rgb = diffuse*lavaglow;
        @(gdepthpackfrag)
    }
]

lazyshader 0 "waterfallenv" [
    attribute vec4 vvertex;
    attribute vec3 vnormal;
    uniform mat4 camprojmatrix;
    uniform vec4 camera;
    varying vec3 camdir;
    varying mat3 world;
    uniform vec4 waterfalltexgen;
    varying vec2 texcoord0;
    @(ginterpvert 1)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        camdir = camera.xyz - vvertex.xyz;
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(vnormal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(vnormal.z));
        world = mat3(tangent, bitangent, vnormal);
        vec2 tc = vec2(dot(vvertex.xy, tangent.xy), dot(vvertex.yz, bitangent.yz));
        texcoord0 = (tc + waterfalltexgen.zw) * waterfalltexgen.xy;
        @(gdepthpackvert 1)
    }
] [
    @(gfetchdefs [tex7 tex8])
    uniform samplerCube tex3;
    uniform sampler2D tex0, tex1;
    uniform vec3 waterfallcolor;
    uniform float waterfallspec;
    uniform vec4 waterfallrefract;
    uniform float refractdepth;
    varying vec3 camdir;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpfrag 1)

    void main(void)
    {
        vec3 camvec = normalize(camdir);
        vec3 diffuse = texture2D(tex0, texcoord0).rgb;
        vec3 bump = texture2D(tex1, texcoord0).rgb*2.0 - 1.0;
        vec3 bumpw = normalize(world * bump);

        vec2 rtc = bump.xy * waterfallrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb * waterfallrefract.xyz;

        float invfresnel = dot(camvec, bumpw);
        vec3 env = textureCube(tex3, 2.0*bumpw*invfresnel - camvec).rgb;
        env *= 0.1 + 0.4*pow(clamp(1.0 - invfresnel, 0.0, 1.0), 2.0);

        gcolor.rgb = vec3(0.0);
        @(gspecpack 2.0 [waterfallspec*(1.0 - dot(diffuse, vec3(0.33)))]);
        @(gnormpack bumpw)
        gglow.rgb = mix(rcolor, waterfallcolor, diffuse) + env;
        @(gdepthpackfrag)
    }
]

lazyshader 0 "waterfall" [
    attribute vec4 vvertex;
    attribute vec3 vnormal;
    uniform mat4 camprojmatrix;
    varying mat3 world;
    uniform vec4 waterfalltexgen;
    varying vec2 texcoord0;
    @(ginterpvert 1)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(vnormal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(vnormal.z));
        world = mat3(tangent, bitangent, vnormal);
        vec2 tc = vec2(dot(vvertex.xy, tangent.xy), dot(vvertex.yz, bitangent.yz));
        texcoord0 = (tc + waterfalltexgen.zw) * waterfalltexgen.xy;
        @(gdepthpackvert 1)
    }
] [
    @(gfetchdefs [tex7 tex8])
    uniform sampler2D tex0, tex1;
    uniform vec3 waterfallcolor;
    uniform float waterfallspec;
    uniform vec4 waterfallrefract;
    uniform float refractdepth;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpfrag 1)

    void main(void)
    {
        vec3 diffuse = texture2D(tex0, texcoord0).rgb;
        vec3 bump = texture2D(tex1, texcoord0).rgb*2.0 - 1.0;
        vec3 bumpw = normalize(world * bump);

        vec2 rtc = bump.xy * waterfallrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb * waterfallrefract.xyz;

        gcolor.rgb = vec3(0.0);
        @(gspecpack 2.0 [waterfallspec*(1.0 - dot(diffuse, vec3(0.33)))])
        @(gnormpack bumpw)
        gglow.rgb = mix(rcolor, waterfallcolor, diffuse);
        @(gdepthpackfrag)
    }
]

lazyshader 0 "glassenv" [
    attribute vec4 vvertex;
    attribute vec3 vnormal;
    uniform mat4 camprojmatrix;
    uniform vec4 camera;
    varying vec3 camdir;
    varying mat3 world;
    uniform vec2 glasstexgen;
    varying vec2 texcoord0;
    @(ginterpvert 1)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        camdir = camera.xyz - vvertex.xyz;
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(vnormal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(vnormal.z));
        world = mat3(tangent, bitangent, vnormal);
        vec2 tc = vec2(dot(vvertex.xy, tangent.xy), dot(vvertex.yz, bitangent.yz));
        texcoord0 = tc * glasstexgen;
        @(gdepthpackvert 1)
    }
] [
    @(gfetchdefs [tex7 tex8])
    uniform samplerCube tex0;
    uniform sampler2D tex1;
    uniform float glassspec;
    uniform vec4 glassrefract;
    uniform float refractdepth;
    varying vec3 camdir;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpfrag 1)

    void main(void)
    {
        vec3 camvec = normalize(camdir);
        vec3 bump = texture2D(tex1, texcoord0).rgb*2.0 - 1.0;
        vec3 bumpw = normalize(world * bump);

        vec2 rtc = bump.xy * glassrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb;
        rcolor *= glassrefract.xyz;

        float invfresnel = dot(camvec, bumpw);
        vec3 env = textureCube(tex0, 2.0*bumpw*invfresnel - camvec).rgb;
        env *= 0.1 + 0.4*pow(clamp(1.0 - invfresnel, 0.0, 1.0), 2.0);

        gcolor.rgb = vec3(0.0);
        @(gspecpack 2.0 glassspec)
        @(gnormpack bumpw)
        gglow.rgb = rcolor + env;
        @(gdepthpackfrag)
    }
]

lazyshader 0 "glass" [
    attribute vec4 vvertex;
    attribute vec3 vnormal;
    uniform mat4 camprojmatrix;
    varying mat3 world;
    uniform vec2 glasstexgen;
    varying vec2 texcoord0;
    @(ginterpvert 1)
    void main(void)
    {
        gl_Position = camprojmatrix * vvertex;
        vec3 tangent = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), abs(vnormal.x));
        vec3 bitangent = mix(vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), abs(vnormal.z));
        world = mat3(tangent, bitangent, vnormal);
        vec2 tc = vec2(dot(vvertex.xy, tangent.xy), dot(vvertex.yz, bitangent.yz));
        texcoord0 = tc * glasstexgen;
        @(gdepthpackvert 1)
    }
] [
    @(gfetchdefs [tex7 tex8])
    uniform sampler2D tex1;
    uniform float glassspec;
    uniform vec4 glassrefract;
    uniform float refractdepth;
    varying mat3 world;
    varying vec2 texcoord0;
    @(ginterpfrag 1)

    void main(void)
    {
        vec3 bump = texture2D(tex1, texcoord0).rgb*2.0 - 1.0;
        vec3 bumpw = normalize(world * bump);

        vec2 rtc = bump.xy * glassrefract.w;
        float rmask = clamp(refractdepth*(lineardepth - dot(gfetch(tex7, gl_FragCoord.xy + rtc).rgb, gdepthunpackparams)), 0.0, 1.0);
        rtc = gl_FragCoord.xy + rtc*rmask;
        vec3 rcolor = gfetch(tex8, rtc).rgb;
        rcolor *= glassrefract.xyz;

        gcolor.rgb = vec3(0.0);
        @(gspecpack 2.0 glassspec)
        @(gnormpack bumpw)
        gglow.rgb = rcolor;
        @(gdepthpackfrag)
    }
]

// I won't lie, this is heavily inspired by Red Eclipse's 'haze' code https://github.com/redeclipse/base
airrefractionshader = [
    lazyshader 0 $arg1 [
        attribute vec4 vvertex;
        @(if (>= (strstr $arg1 "tex") 0) [result [
            uniform float millis;
            uniform vec4 artexgen;
            varying vec2 texcoord0, texcoord1, texcoord2;
        ]])
        void main(void)
        {
            gl_Position = vvertex;
            @(if (>= (strstr $arg1 "tex") 0) [result [
                texcoord0 = (vvertex.xy + artexgen.zw) * artexgen.xy;
                texcoord1 = texcoord0 * 0.18 + millis*vec2( 0.25,  0.75)*0.1250;
                texcoord2 = texcoord0 * 0.18 + millis*vec2(-0.75, -0.25)*0.1450;
            ]])
        }
    ] [
        @(gfetchdefs [tex9])
        uniform float arstrenght;
        uniform vec4 arcolor, arparams;
        @(if (>= (strstr $arg1 "tex") 0) [result [
            uniform sampler2D tex0;
            uniform sampler2DRect tex8;
            varying vec2 texcoord0, texcoord1, texcoord2;
        ]])
        fragdata(0) vec4 fragcolor;
        void main(void)
        {
            @(gdepthunpack depth [gfetch(tex9, gl_FragCoord.xy)])
            float dist = -depth;
            if(dist <= 0) dist = -gdepthunpackparams.x;
            if(dist < arparams.x) discard;

            float offset = dist - arparams.x;
            float mixer = clamp(offset*arparams.y, 0.0, 1.0);
            float alpha = clamp(offset*arparams.z, 0.0, 1.0);

            @(if (>= (strstr $arg1 "tex") 0) [result [
                vec3 bump = texture2D(tex0, texcoord0).rgb * 2.0 - 1.0;
                vec3 col = texture2DRect(tex8, gl_FragCoord.xy + (bump.xy * arstrenght)).rgb;

                fragcolor.rgb = mix(col, arcolor.rgb, mixer * arcolor.a);
                fragcolor.a = alpha * arparams.w;
            ]] [result [
                fragcolor.rgb = arcolor.rgb;
                fragcolor.a = mixer * arcolor.a * alpha;
            ]])
        }
    ]
]
airrefractionshader "ars"
airrefractionshader "arstex"

lazyshader 0 "testvolumetricclouds" [
    attribute vec4 vvertex;
    void main(void)
    {
        gl_Position = vvertex;
    }
] [
    @(gfetchdefs tex9)
    uniform vec3 camera;
    uniform vec3 sunlightdir;
    uniform mat4 worldmatrix;
    uniform vec4 tvcloudscale; // x,y = fullres/rt, z,w = rt/fullres
    uniform vec4 tvcloudbounds; // x=base z, y=top z, z=max dist, w=time
    uniform vec4 tvcloudnoise;  // x=base scale, y=detail scale, z=threshold, w=density
    uniform vec4 tvcloudcolor;  // rgb=tint, a=opacity
    fragdata(0) vec4 fragcolor;

    float tvhash(vec3 p)
    {
        return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123);
    }

    float tvnoise3(vec3 p)
    {
        vec3 i = floor(p), f = fract(p);
        vec3 u = f*f*(3.0 - 2.0*f);

        float n000 = tvhash(i + vec3(0.0, 0.0, 0.0));
        float n100 = tvhash(i + vec3(1.0, 0.0, 0.0));
        float n010 = tvhash(i + vec3(0.0, 1.0, 0.0));
        float n110 = tvhash(i + vec3(1.0, 1.0, 0.0));
        float n001 = tvhash(i + vec3(0.0, 0.0, 1.0));
        float n101 = tvhash(i + vec3(1.0, 0.0, 1.0));
        float n011 = tvhash(i + vec3(0.0, 1.0, 1.0));
        float n111 = tvhash(i + vec3(1.0, 1.0, 1.0));

        float nx00 = mix(n000, n100, u.x);
        float nx10 = mix(n010, n110, u.x);
        float nx01 = mix(n001, n101, u.x);
        float nx11 = mix(n011, n111, u.x);
        float nxy0 = mix(nx00, nx10, u.y);
        float nxy1 = mix(nx01, nx11, u.y);
        return mix(nxy0, nxy1, u.z);
    }

    float tvfbm(vec3 p)
    {
        float v = 0.0, a = 0.5;
        for(int i = 0; i < 4; ++i)
        {
            v += a * tvnoise3(p);
            p = p * 2.03 + vec3(7.3, 19.1, 3.7);
            a *= 0.5;
        }
        return v;
    }

    float tvdensity(vec3 p)
    {
        float thickness = max(tvcloudbounds.y - tvcloudbounds.x, 1.0);
        float h = clamp((p.z - tvcloudbounds.x) / thickness, 0.0, 1.0);
        float layer = smoothstep(0.05, 0.35, h) * (1.0 - smoothstep(0.65, 0.98, h));

        vec3 windp = p;
        windp.xy += vec2(tvcloudbounds.w * 28.0, tvcloudbounds.w * 12.0);
        windp.z += tvcloudbounds.w * 2.0;

        float base = tvfbm(windp * tvcloudnoise.x);
        float detail = tvfbm((windp + vec3(13.0, -9.0, 17.0)) * tvcloudnoise.y);
        float shape = mix(base, detail, 0.28);
        float d = smoothstep(tvcloudnoise.z, tvcloudnoise.z + 0.16, shape);
        return d * layer * tvcloudnoise.w;
    }

    float tvsuntrans(vec3 p, vec3 sdir, float thickness)
    {
        if(sdir.z <= 1.0e-3) return 1.0;
        float tmax = (tvcloudbounds.y - p.z) / sdir.z;
        if(tmax <= 0.0) return 1.0;

        tmax = min(tmax, thickness * 6.0);
        const int TV_SUN_STEPS = 4;
        float stepdist = max(tmax / float(TV_SUN_STEPS), 1.0e-3);
        float t = stepdist * 0.35;
        float trans = 1.0;
        for(int j = 0; j < TV_SUN_STEPS; ++j)
        {
            float d = tvdensity(p + sdir * t);
            float a = clamp(d * (stepdist / thickness) * 10.0, 0.0, 0.65);
            trans *= 1.0 - a;
            t += stepdist;
            if(trans < 0.05) break;
        }
        return trans;
    }

    void main(void)
    {
        vec2 screentc = gl_FragCoord.xy * tvcloudscale.xy;
        @(gdepthunpack depth [gfetch(tex9, screentc)] [
            vec3 wpos = (worldmatrix * vec4(depth*screentc, depth, 1.0)).xyz;
        ] [
            vec4 wpos = worldmatrix * vec4(screentc, depth, 1.0);
            wpos.xyz /= wpos.w;
        ])

        vec3 rayvec = wpos.xyz - camera;
        float scenedist = length(rayvec);
        if(!(scenedist > 0.0)) scenedist = tvcloudbounds.z;
        scenedist = min(scenedist, tvcloudbounds.z);
        if(scenedist <= 1.0)
        {
            fragcolor = vec4(0.0);
            return;
        }

        vec3 ray = rayvec / max(scenedist, 1.0e-4);
        float t0 = 0.0, t1 = scenedist;

        if(abs(ray.z) < 1.0e-4)
        {
            if(camera.z < tvcloudbounds.x || camera.z > tvcloudbounds.y)
            {
                fragcolor = vec4(0.0);
                return;
            }
        }
        else
        {
            float invrz = 1.0 / ray.z;
            float tz0 = (tvcloudbounds.x - camera.z) * invrz;
            float tz1 = (tvcloudbounds.y - camera.z) * invrz;
            if(tz0 > tz1) { float t = tz0; tz0 = tz1; tz1 = t; }
            t0 = max(t0, tz0);
            t1 = min(t1, tz1);
        }

        t0 = max(t0, 24.0);
        if(t1 <= t0)
        {
            fragcolor = vec4(0.0);
            return;
        }

        const int TV_STEPS = 16;
        float thickness = max(tvcloudbounds.y - tvcloudbounds.x, 1.0);
        float raylen = t1 - t0;
        float stepdist = raylen / float(TV_STEPS);
        float jitter = tvhash(vec3(gl_FragCoord.xy, tvcloudbounds.w));
        float t = t0 + jitter * stepdist;
        float slen = max(length(sunlightdir), 1.0e-4);
        vec3 sdir = sunlightdir / slen;
        float sunup = clamp(sdir.z * 0.5 + 0.5, 0.0, 1.0);

        vec3 accum = vec3(0.0);
        float trans = 1.0;
        for(int i = 0; i < TV_STEPS; ++i)
        {
            if(t > t1 || trans < 0.03) break;

            vec3 p = camera + ray * t;
            float d = tvdensity(p);
            if(d > 1.0e-4)
            {
                float h = clamp((p.z - tvcloudbounds.x) / thickness, 0.0, 1.0);
                float suntrans = tvsuntrans(p, sdir, thickness);
                float phase = pow(clamp(dot(ray, sdir) * 0.5 + 0.5, 0.0, 1.0), 6.0);
                float ambient = mix(0.22, 0.42, h) + 0.18 * sunup;
                float direct = max(sdir.z, 0.0) * suntrans * (0.35 + 0.95 * phase);
                float light = ambient + direct;
                light *= mix(0.80, 1.05, tvnoise3(p * (tvcloudnoise.x * 0.35) + vec3(2.0, 11.0, 5.0)));

                float sigma = d * (stepdist / thickness) * (12.0 * tvcloudcolor.a);
                float alpha = clamp(sigma, 0.0, 0.55);
                vec3 litcol = mix(tvcloudcolor.rgb * vec3(0.78, 0.82, 0.90), tvcloudcolor.rgb, suntrans);
                vec3 samplecol = litcol * light;

                accum += trans * alpha * samplecol;
                trans *= 1.0 - alpha;
            }

            t += stepdist;
        }

        float outalpha = 1.0 - trans;
        outalpha *= smoothstep(0.0, tvcloudbounds.z * 0.15, t0);
        fragcolor = vec4(accum, outalpha);
    }
]
